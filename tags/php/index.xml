<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>php on 随笔记</title>
    <link>https://weekthree.github.io/tags/php/</link>
    <description>Recent content in php on 随笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 10 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://weekthree.github.io/tags/php/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Array 函数效率问题</title>
      <link>https://weekthree.github.io/p/array-%E5%87%BD%E6%95%B0%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://weekthree.github.io/p/array-%E5%87%BD%E6%95%B0%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/</guid>
      <description>起因 PHP Array 函数是 PHP 核心的组成部分，我们在编写 PHP 代码的时候，这些内置的 Array 函数给我们提供了极大的便利。但是有一次我发现在测试环境执行无异常的代码，在线上执行却超时了。 开始以为是代码里面有 SQL 慢查询导致的，但是排查相关的数据库语句并没有发现什么问题。最后定位到一段遍历语句当中，里面用到了三个数组函数，分别是数组合并函数array_merge()，数组查找函数array_search()和in_array()。 我们先看下面这段垃圾代码。
foreach ($poolStr as $poolIds) { $poolId = explode(&amp;#39;,&amp;#39;, $poolIds); $batchPool = array_merge($batchPool, $poolId); } ... foreach ($batchPool as $bp) { $postId = array_search($bp,$turnPool); if ($postId &amp;amp;&amp;amp; in_array($postId,$onlinePost)) { //do somgthing } } 通过分析，意识到虽然这里并没有相关的数据库查询操作，但是遍历可能涉及到大量的循环，相关内置函数的效率问题会明显放大。 下面用例子证明一下。（使用相同的range()函数创建一样长度的数组，这次不考虑range()函数的时间消耗。)
Array 函数 array_merge() 我们循环10000次，每次生成10个元素的数组，然后使用array_merge()函数合并成一个大数组。经过测试发现，10000次循环合并就要花费4秒多。
&amp;lt;?php /** * 获取毫秒 */ if (!function_exists(&amp;#39;getMsectime&amp;#39;)) { function getMsectime() { list($msec, $sec) = explode(&amp;#39; &amp;#39;, microtime()); return (float)sprintf(&amp;#39;%.</description>
    </item>
    
    <item>
      <title>Php 垃圾回收机制</title>
      <link>https://weekthree.github.io/p/php-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 29 Aug 2021 10:55:45 +0800</pubDate>
      
      <guid>https://weekthree.github.io/p/php-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
      <description>概念 PHP本身实现了垃圾回收机制(Garbage Collection)，让程序员不必过分关心程序内存分配，从而将更多的精力投入到业务逻辑。
PHP中的变量划分为三大类：
标量数据类型 包括布尔型、整型、浮点型和字符串 复合数据类型。 包括数组、对象; 特殊数据类型 包括资源、null PHP变量的管理基于引用计数+写时复制实现的。
引用计数 PHP把所有类型变量都存在一个叫 &amp;ldquo;zval&amp;quot;的变量容器中，变量的内存是通过引用计数进行管理的。 zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息
is_ref a. bool类型，用来表示变量是否属于引用集合。 refcount a. 表示指向这个zval变量容器的变量个数。 PHP 5.x 在PHP5中，zval 的内存是单独从堆中分配的，PHP 需要知道哪些 zval 是正在使用的，哪些是需要释放的。所以这就需要用到引用计数来保存zval本身被引用的次数。如果引用计数变成 0，就意味着这个变量已经没有用了，内存也就可以释放了。
标量类型 当一个变量被赋常量值时，就会生成一个zval变量容器。
$a = &amp;#34;hello&amp;#34;; xdebug_debug_zval(&amp;#39;a&amp;#39;); a: (refcount=1, is_ref=0),string &amp;#39;hello&amp;#39; (length=5) 这里只有一个变量使用这个变量容器，所以refcount=1。 没有任何自定义的引用， 所以is_ref也是0。
把一个变量赋值给另一变量将增加引用次数。
$a = &amp;#34;hello&amp;#34;; $b = $a; xdebug_debug_zval(&amp;#39;a&amp;#39;); xdebug_debug_zval(&amp;#39;b&amp;#39;); $b = &amp;#34;hi&amp;#34;; xdebug_debug_zval(&amp;#39;a&amp;#39;); xdebug_debug_zval(&amp;#39;b&amp;#39;); a: (refcount=2, is_ref=0),string &amp;#39;hello&amp;#39; (length=5) b: (refcount=2, is_ref=0),string &amp;#39;hello&amp;#39; (length=5) a: (refcount=1, is_ref=0),string &amp;#39;hello&amp;#39; (length=5) b: (refcount=1, is_ref=0),string &amp;#39;hi&amp;#39; (length=2) 当执行 $b=$a时，引用次数是2，因为同一个变量容器被变量a和变量b关联，这时候PHP还没有必要去复制已生成的变量容器。当$b重新赋值时，才会进行内存复制，此时refcount分别都变成1。</description>
    </item>
    
  </channel>
</rss>
