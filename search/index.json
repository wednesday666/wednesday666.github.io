[{"content":"起因 PHP Array 函数是 PHP 核心的组成部分，我们在编写 PHP 代码的时候，这些内置的 Array 函数给我们提供了极大的便利。但是有一次我发现在测试环境执行无异常的代码，在线上执行却超时了。 开始以为是代码里面有 SQL 慢查询导致的，但是排查相关的数据库语句并没有发现什么问题。最后定位到一段遍历语句当中，里面用到了三个数组函数，分别是数组合并函数array_merge()，数组查找函数array_search()和in_array()。 我们先看下面这段垃圾代码。\n1 2 3 4 5 6 7 8 9 10 11 12 foreach ($poolStr as $poolIds) { $poolId = explode(\u0026#39;,\u0026#39;, $poolIds); $batchPool = array_merge($batchPool, $poolId); } ... foreach ($batchPool as $bp) { $postId = array_search($bp,$turnPool); if ($postId \u0026amp;\u0026amp; in_array($postId,$onlinePost)) { //do somgthing } } 通过分析，意识到虽然这里并没有相关的数据库查询操作，但是遍历可能涉及到大量的循环，相关内置函数的效率问题会明显放大。 下面用例子证明一下。（使用相同的range()函数创建一样长度的数组，这次不考虑range()函数的时间消耗。)\nArray 函数 array_merge() 我们循环10000次，每次生成10个元素的数组，然后使用array_merge()函数合并成一个大数组。经过测试发现，10000次循环合并就要花费4秒多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php /** * 获取毫秒 */ if (!function_exists(\u0026#39;getMsectime\u0026#39;)) { function getMsectime() { list($msec, $sec) = explode(\u0026#39; \u0026#39;, microtime()); return (float)sprintf(\u0026#39;%.0f\u0026#39;, (floatval($msec) + floatval($sec)) * 1000); } } $time_s = getMsectime(); $arr = []; for ($i=0; $i\u0026lt;=10000; $i++){ $newArr = range(0,10); $arr = array_merge($arr,$newArr); } $time_e = getMsectime(); $time_u = $time_e - $time_s; echo \u0026#34;时间开销:{$time_u}ms \u0026#34;; echo \u0026#34;元素个数\u0026#34;.count($arr); //输出结果 //时间开销:4368ms 元素个数110011 因为我们不关注键名，可以直接使用array_push替代，得到相同的数据，时间只需要5毫秒。array_merge()函数与其相比，性能相差了千倍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 $time_s = getMsectime(); $arr = []; for ($i=0; $i\u0026lt;=10000; $i++){ $newArr = range(0,10); array_push($arr,...$newArr); } $time_e = getMsectime(); $time_u = $time_e - $time_s; echo \u0026#34;时间开销:{$time_u}ms \u0026#34;; echo \u0026#34;元素个数\u0026#34;.count($arr); //输出结果 //时间开销:5ms 元素个数110011 array_search() 使用range()函数生成1-9999的数字元素的数组。使用array_search()执行50万次查找操作，花费了将近7秒的时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $time_s = getMsectime(); $arr = []; $newArr = range(1,9999); $nums = 0; for ($i=0; $i\u0026lt;=500000; $i++){ if(array_search($i,$newArr) !== false){ $nums++; } } $time_e = getMsectime(); $time_u = $time_e - $time_s; echo \u0026#34;时间开销:{$time_u}ms \u0026#34;; echo \u0026#34;存在元素个数{$nums}个\u0026#34;; //输出结果 //时间开销:6696ms 存在元素个数9999个 in_array() 与array_search()半斤八两的in_array()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $time_s = getMsectime(); $arr = []; $newArr = range(1,9999); $nums = 0; for ($i=0; $i\u0026lt;=500000; $i++){ if(in_array($i,$newArr) !== false){ $nums++; } } $time_e = getMsectime(); $time_u = $time_e - $time_s; echo \u0026#34;时间开销:{$time_u}ms \u0026#34;; echo \u0026#34;存在元素个数{$nums}个\u0026#34;; //输出结果 //时间开销:5932ms 存在元素个数9999个 我们进行如下优化，使用array_flip()先将整个数组进行反转。然后使用array_key_exists()在反转后的数组中查找需要搜索的key，大大提升搜索的效率。 当然，这里也可以使用isset()，它使用了与array_key_exists()相同的操作，而且，由于isset()属于语言结构，在重复使用相同 key 的情况下会利用缓存提升效率。经过测试，isset()确实比array_key_exists()快那么一丢丢。 下面是时间复杂度相关的资料，in_array() 和array_search()都是O(n)，array_key_exists()和isset()为O(1)。\narray_key_exists O(n) but really close to O(1) - this is because of linear polling in collisions, but because the chance of collisions is very small, the coefficient is also very small. I find you treat hash lookups as O(1) to give a more realistic big-O. For example the different between N=1000 and N=100000 is only about 50% slow down. isset( $array[$index] ) O(n) but really close to O(1) - it uses the same lookup as array_key_exists. Since it\u0026rsquo;s language construct, will cache the lookup if the key is hardcoded, resulting in speed up in cases where the same key is used repeatedly. in_array O(n) - this is because it does a linear search though the array until it finds the value. array_search O(n) - it uses the same core function as in_array but returns value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 $time_s = getMsectime(); $arr = []; $newArr = range(1,9999); $nums = 0; $newArr = array_flip($newArr); for ($i=0; $i\u0026lt;=500000; $i++){ if(array_key_exists($i,$newArr)){ $nums++; } /* 使用isset也可以 if(isset($newArr[$i]) !== false){ $nums++; } */ } $time_e = getMsectime(); $time_u = $time_e - $time_s; echo \u0026#34;时间开销:{$time_u}ms \u0026#34;; echo \u0026#34;存在元素个数{$nums}个\u0026#34;; //输出结果 //array_key_exists //时间开销:25ms 存在元素个数9999个 //isset //时间开销:18ms 存在元素个数9999个 先使用array_flip()先将整个数组进行反转，再使用isset()或者array_key_exists()替代数组搜索函数，可以大幅提高执行效率。\n总结 过上面三个例子，我们发现不仅仅是慢速 SQL 会导致我们的程序变慢，不恰当的内置函数的使用也是需要重视的一个点。那么如何在享受内置函数便利的同时，又规避性能陷阱呢？ 这就需要我们对日常高频使用的相关函数的时间复杂度和执行方式都要有个大致的了解，这样才能在不同的场景中找到最适合的函数，也能在出现问题后快速定位，寻找别的实现方式替代。\n参考资料 List of Big-O for PHP functions PHP 手册- Manual ","date":"2022-06-10T00:00:00Z","image":"https://weekthree.github.io/p/array-%E5%87%BD%E6%95%B0%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/1_huef019ec58a04e78cdce296a9631ccd9b_27304_120x120_fill_q75_box_smart1.jpg","permalink":"https://weekthree.github.io/p/array-%E5%87%BD%E6%95%B0%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/","title":"Array 函数效率问题"},{"content":"IO 多线程 Redis 一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF 重写），但是，从网络 IO 处理到实际的读写命令处理，都是由单个线程完成的。\n在 6.0 版本之前，Redis采用了采用了多路 I/O 复用技术，这里的多路指的是多个 socket 网络连接，复用指的是复用同一个线程。通过多路 I/O 复用技术在同一个线程中处理多个 I/O 请求，尽量减少网络 I/O 的消耗，提升使用效率。 但随着网络硬件的性能提升，Redis的性能瓶颈有时会出现在网络 IO 的处理上，单个主线程处理网络请求的速度跟不上底层网络硬件的速度。\n在 6.0 版本中，Redis把请求网络包读写和解析也从主线程中剥离出来了。\nRedis 6.0 采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。但是对于读写命令，仍然使用单线程来处理。\n这样实现有两个好处：\n通过多个IO线程并行处理网络操作，解决网络处理瓶颈提升实例的整体处理性能。 读写命令继续使用单线程处理，可以避免上下文切换和不必要的线程之间引起的资源竞争，线程模型更简单。 处理流程 主线程和多 IO 线程的协作主要分成以下几个阶段：\n服务端和客户端建立 Socket 连接，并分配处理线程。 IO 线程读取并解析请求。 主线程执行请求操作。 IO线程回写 Socket 和主线程清空全局队列 在第2、4阶段，由于加入了 IO 多线程，多个 IO 线程并行处理读取与解析请求，以及回写 Socket 的操作都会很快。因此可以加速网络处理，进而提升实例的吞吐量。 开启多线程 默认情况下，多线程是关闭的。如果需要启动，要在 redis.conf 进行以下配置。\n1 2 3 4 5 #启用多线程 io-threads-do-reads yes #设置线程个数 io-threads 6 需要注意的是，线程个数要小于实例所在的 CPU 核个数。对于 8 核 CPU 的机器，官方建议配置 6 个 IO 线程。 权限控制 在 Redis 6.0 版本之前，只能通过创建一个密码来进行安全控制。只要知道密码，就能执行类似 KEYS、FLUSHDB、FLUSHALL 等各种危险的操作。\nRedis 6.0 提供了更加细粒度的访问权限控制。\n升级到 6.0 版本后，配置文件只设置了密码，客户端登录的时候是需要指定默认用户名default。\n创建不同用户 Redis 6.0 版本之前所有使用者通过一个密码登陆使用，没有账号的概念。而在 Redis 6.0 可以通过使用 ACL SETUSER 给使用者创建不同的用户账号。\n1 2 #创建并启用samuel账号，密码为123 ACL SETUSER samuel on \u0026gt;123 根据命令操作设置访问权限 Redis 6.0 支持以用户为粒度设置命令操作的访问权限。例如：\n1 2 #给用户 samuel 开启 get 操作的权限。 ACL SETUSER samuel +get 根据类型设置访问权限 也可以根据不同的数据类型来给用户授权例如：\n1 2 #限制用户只能操作 Hash 类的命令，不能调用 String 类型的命令 ACL SETUSER samuel +@hash -@string 根据key设置访问权限 使用波浪号 \u0026ldquo;~\u0026rdquo; 和 key 的前缀来表示访问控制的 key。例如：\n1 2 3 4 5 #设置用户 samuel 只能对以 \u0026#34;user:\u0026#34; 为前缀的 key 进行命令操作 ACL SETUSER samuel ~user:* +@all #设置用户 samuel 可以进行所有操作 ACL SETUSER samuel ~* +@all Redis 6.0 可以创建不同用户来访问实例，而且可以基于用户和 key 的粒度，设置某个用户对某些 key 允许或禁止执行的命令操作。\n这样一来，我们在有多用户的 Redis 应用场景下，就可以非常方便和灵活地为不同用户设置不同级别的命令操作权限，这对于提供安全的 Redis 访问非常有帮助。\n操作 作用 + 将一个命令添加到用户可以调用的命令列表中 - 将一个命令从用户可以调用的命令列表中移除 +@ 将一类命令添加到用户可以调用的命令列表中 -@ 将一类命令从用户可以调用的命令列表中移除 +@all 允许调用所有的命令操作 -@all 禁止调用所有命令操作 客户端缓存 Redis 6.0 新增了跟踪 （Tracking）功能，也就是实现了服务端协助的客户端缓存，业务应用中 Redis 客户端可以把读取的数据缓存在业务应用本地了，应用就可以直接在本地快速读取数据了。\nTracking 功能通过下面两种模式，来解决客户端对已缓存但失效的数据同步处理。 普通模式 这种模式下，实例会在客户端记录客户端读取过的 key，并检测 key 是否有修改。一旦 key 的值发生变化，服务端会给客户端发送 invalidate 消息。通知客户端缓存失效，客户端下次请求就需要从服务端获取最新数据。\n通过以下命令开启或关闭普通模式下 Tracking 功能。\n1 CLIENT TRACKING ON|OFF 需要注意的是，为了节省服务端的内存空间，对于客户端不再访问的 key ，服务端是不会记录这个 key 的修改情况的。就算是之前已经发送过 invalidate 消息的key，如果此后客户端没有再次执行读命令。之后这个 key 再被修改，服务端就不会再次给客户端发送 invalidate 消息。\n总结：Server 端全局唯一的表（Invalidation Table）记录每个Client访问的Key，当发生变更时，向client推送数据过期消息。\n优点：只对Client发送其访问过的被修改的数据 缺点：Server端需要额外存储较大的数据量 广播模式 这种模式下，服务端会给客户端广播所有 key 的失效情况。\n为了防止 key 在频繁修改的情况下，服务端发送大量失效广播消息造成大量网络带宽资源被消耗。客户端需要跟踪指定前缀的 key，这样让服务端针对性的发送失效信息给客户端。\n1 CLIENT TRACKING ON BCAST PREFIX user 类似上面的命令操作。只有更新了 user: 前缀的key，客户端才会收到 invalidate 消息。和普通模式不同，就算客户端还没有读取过 key，只要注册了跟踪前缀，服务端就会把这个 key 失效消息通知给客户端。\n总结：客户端订阅 key 前缀的广播，服务端记录 key 前缀与 client 的对应关系。当相匹配的 key 发生变化时通知 client\n优点：服务端记录信息比较少 缺点：client 会收到自己未访问过的 key 的失效通知 RESP3 协议 RESP（Redis Serialization Protocol）是 Redis 服务端与客户端之间通信的协议。RES P协议在Redis 1.2中引入，在Redis 2.0中成为与Redis服务器通信的标准方式。而 Redis 6 开始在兼容 RESP2 的基础上，开始支持 RESP3。\n推出 RESP3 的目的：一是因为希望能为客户端提供更多的语义化响应，以开发使用旧协议难以实现的功能；另一个原因就是为了实现上面提到的客户端缓存功能功能。 总结 面向网络处理的多 IO 线程可以提高网络请求处理的速度，而客户端缓存可以让应用直接在客户端本地读取数据，这两个特性可以提升 Redis 的性能。\n除此之外，细粒度权限控制让 Redis 可以按照命令粒度控制不同用户的访问权限，加强了 Redis 的安全保护。RESP 3 协议则增强客户端的功能，可以让应用更加方便地使用 Redis 的不同数据类型。 参考 极客时间《Redis 核心技术与实战》- 蒋德钧 ","date":"2021-11-09T00:00:00Z","image":"https://weekthree.github.io/p/redis-6.0%E6%96%B0%E7%89%B9%E6%80%A7/1_hud786c9f01eac1c004fde2d76b8d3cf7a_38228_120x120_fill_q75_box_smart1.jpg","permalink":"https://weekthree.github.io/p/redis-6.0%E6%96%B0%E7%89%B9%E6%80%A7/","title":"Redis 6.0新特性"},{"content":"概念 PHP本身实现了垃圾回收机制(Garbage Collection)，让程序员不必过分关心程序内存分配，从而将更多的精力投入到业务逻辑。\nPHP中的变量划分为三大类：\n标量数据类型 包括布尔型、整型、浮点型和字符串 复合数据类型。 包括数组、对象; 特殊数据类型 包括资源、null PHP变量的管理基于引用计数+写时复制实现的。\n引用计数 PHP把所有类型变量都存在一个叫 \u0026ldquo;zval\u0026quot;的变量容器中，变量的内存是通过引用计数进行管理的。 zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息\nis_ref a. bool类型，用来表示变量是否属于引用集合。 refcount a. 表示指向这个zval变量容器的变量个数。 PHP 5.x 在PHP5中，zval 的内存是单独从堆中分配的，PHP 需要知道哪些 zval 是正在使用的，哪些是需要释放的。所以这就需要用到引用计数来保存zval本身被引用的次数。如果引用计数变成 0，就意味着这个变量已经没有用了，内存也就可以释放了。\n标量类型 当一个变量被赋常量值时，就会生成一个zval变量容器。\n1 2 $a = \u0026#34;hello\u0026#34;; xdebug_debug_zval(\u0026#39;a\u0026#39;); 1 2 a: (refcount=1, is_ref=0),string \u0026#39;hello\u0026#39; (length=5) 这里只有一个变量使用这个变量容器，所以refcount=1。 没有任何自定义的引用， 所以is_ref也是0。\n把一个变量赋值给另一变量将增加引用次数。\n1 2 3 4 5 6 7 $a = \u0026#34;hello\u0026#34;; $b = $a; xdebug_debug_zval(\u0026#39;a\u0026#39;); xdebug_debug_zval(\u0026#39;b\u0026#39;); $b = \u0026#34;hi\u0026#34;; xdebug_debug_zval(\u0026#39;a\u0026#39;); xdebug_debug_zval(\u0026#39;b\u0026#39;); 1 2 3 4 5 6 7 8 a: (refcount=2, is_ref=0),string \u0026#39;hello\u0026#39; (length=5) b: (refcount=2, is_ref=0),string \u0026#39;hello\u0026#39; (length=5) a: (refcount=1, is_ref=0),string \u0026#39;hello\u0026#39; (length=5) b: (refcount=1, is_ref=0),string \u0026#39;hi\u0026#39; (length=2) 当执行 $b=$a时，引用次数是2，因为同一个变量容器被变量a和变量b关联，这时候PHP还没有必要去复制已生成的变量容器。当$b重新赋值时，才会进行内存复制，此时refcount分别都变成1。\n传引用后，is_ref会变成1。\n1 2 3 4 5 6 7 8 9 $a = \u0026#34;hello\u0026#34;; $b = $a; xdebug_debug_zval(\u0026#39;a\u0026#39;); xdebug_debug_zval(\u0026#39;b\u0026#39;); $c = \u0026amp;$a; $a = \u0026#34;hi\u0026#34;; xdebug_debug_zval(\u0026#39;a\u0026#39;); xdebug_debug_zval(\u0026#39;b\u0026#39;); xdebug_debug_zval(\u0026#39;c\u0026#39;); 1 2 3 4 5 6 7 8 9 10 a: (refcount=2, is_ref=0),string \u0026#39;hello\u0026#39; (length=5) b: (refcount=2, is_ref=0),string \u0026#39;hello\u0026#39; (length=5) a: (refcount=2, is_ref=1),string \u0026#39;hi\u0026#39; (length=2) b: (refcount=1, is_ref=0),string \u0026#39;hello\u0026#39; (length=5) c: (refcount=2, is_ref=1),string \u0026#39;hi\u0026#39; (length=2) 变量a和b开始使用的是同一变量容器。$a传引用给$c后，a,c指向的是同一个变量容器，所以is_ref=1，refcount=2。 b后面使用单独的变量容器，refcount变为1。\n当任何关联到某个变量容器的变量离开它的作用域，例如函数执行结束或者对变量执行了unset()，refcount就会减少1,变量容器在refcount变成0时就会被销毁。\n1 2 3 4 5 6 7 8 9 10 $a = \u0026#34;hello\u0026#34;; $c = $b = $a; $e = \u0026amp;$a; $a = \u0026#34;hi\u0026#34;; unset($a); unset($b); xdebug_debug_zval(\u0026#39;a\u0026#39;); xdebug_debug_zval(\u0026#39;b\u0026#39;); xdebug_debug_zval(\u0026#39;c\u0026#39;); xdebug_debug_zval(\u0026#39;e\u0026#39;); 1 2 3 4 c: (refcount=1, is_ref=0),string \u0026#39;hello\u0026#39; (length=5) e: (refcount=1, is_ref=0),string \u0026#39;hi\u0026#39; (length=2) 如果我们再执行unset($c)和unset($e)，那么这两个变量容器就会从内存中删除。\n复合类型 array和object类型的变量会把他们的成员或属性存在自己的符号表中。\n如下面的例子：\n1 2 3 $a = array(\u0026#39;name\u0026#39;=\u0026gt;\u0026#39;samuel\u0026#39;,\u0026#39;age\u0026#39;=\u0026gt;18); $a[\u0026#39;number\u0026#39;] = $a[\u0026#39;age\u0026#39;]; xdebug_debug_zval(\u0026#39;a\u0026#39;); 1 2 3 4 5 6 a: (refcount=1, is_ref=0), array (size=4) \u0026#39;name\u0026#39; =\u0026gt; (refcount=1, is_ref=0),string \u0026#39;samuel\u0026#39; (length=6) \u0026#39;age\u0026#39; =\u0026gt; (refcount=2, is_ref=0),int 18 \u0026#39;number\u0026#39; =\u0026gt; (refcount=2, is_ref=0),int 18 上面会生成四个zval变量容器,分别是a,name,age,number。 我们使用赋值给数组添加元素后，age和number指向同一个zval变量容器，refcount为2。\n和标量类型一样，unset会使refcount减1，当refcount减为0时，变量容器会从内存中被删除。\n1 2 3 $a = array(\u0026#39;name\u0026#39;=\u0026gt;\u0026#39;samuel\u0026#39;,\u0026#39;age\u0026#39;=\u0026gt;18); unset($a[\u0026#39;age\u0026#39;]); xdebug_debug_zval(\u0026#39;a\u0026#39;); 1 2 3 4 a: (refcount=1, is_ref=0), array (size=1) \u0026#39;name\u0026#39; =\u0026gt; (refcount=1, is_ref=0),string \u0026#39;samuel\u0026#39; (length=6) 循环引用的问题 PHP变量的回收是根据refcount实现的，当unset、return时会将变量的引用计数减掉，如果refcount减到0则直接释放value，这是变量的简单gc过程。 在PHP 5.3之前的版本中，数组循环引用会出现内存无法回收的问题。 如下：\n1 2 3 $a = array( \u0026#39;one\u0026#39; ); $a[] =\u0026amp; $a; xdebug_debug_zval( \u0026#39;a\u0026#39; ); 1 2 3 4 a: (refcount=2, is_ref=1)=array ( 0 =\u0026gt; (refcount=1, is_ref=0)=\u0026#39;one\u0026#39;, 1 =\u0026gt; (refcount=2, is_ref=1)=... ) 当使用unset($a)后，会发生下面的问题。\n1 2 3 4 (refcount=1, is_ref=1)=array ( 0 =\u0026gt; (refcount=1, is_ref=0)=\u0026#39;one\u0026#39;, 1 =\u0026gt; (refcount=1, is_ref=1)=... ) unset($a)之前的引用关系: unset($a)之后：\n尽管不再有某个作用域中的任何符号指向这个结构(就是变量容器)，由于数组子元素仍然指向数组本身，所以这个容器不能被清除 。因为没有另外的符号指向它，用户没有办法清除这个结构，结果就会导致内存泄漏。 这种无法通过简单的gc机制回收的情况下就会产生垃圾，垃圾回收器要处理的就是这种情况，目前垃圾只会出现在array、object两种类型中。 为了解决这问题，PHP 使用了循环回收的方法。当一个 zval 的计数减一时，就有可能属于循环的一部分，这时将 zval 写入到根缓冲区(root buffer)中。当缓冲区满时，潜在的循环会被打上标记并进行回收。\n循环回收 是否加入循环回收判断如下：\n如果一个zval的refcount增加，说明此zval继续在被使用，不是垃圾。 如果引用计数减少到零，所在变量容器将被正常清除。 如果引用计数减少到非零值时，那么此zval有可能成为垃圾，放入缓冲区，这时才会产生垃圾周期。 当一个zval可能为垃圾时，回收算法会把这个zval放入一个根缓冲区。当缓冲区达到最大临界值时（默认10000），回收算法会循环遍历所有缓冲区中的zval，判断其是否为垃圾，并进行释放处理。\n执行步骤 如下：\n根据深度优先遍历所有根zval,将每个成员模拟删除,使成员的refcount减1。每个变量只能被模拟删除一次，模拟删除后进行标记。 再次遍历，将引用计数大于0的zval模拟恢复，refcount加1。每个变量也只能恢复一次，恢复后进行标记。为0的保持不变。 销毁所有refcount为0的zval，并收回其内存。 （下面这个图是PHP文档上抄的，看了半天没明天灰色的refcount =C 是啥回事，后面发现应该是O才对，估计没印好，不知道PHP文档上哪里抄来的图） 核心原理 这个算法的原理很简单，垃圾是由于成员引用自身导致的，那么就对所有的成员减一遍引用，如果发现最后变量本身的 refcount 变为了 0 则就表明其引用全部来自自身成员，即其他任何地方都不再使用它，那么它就是垃圾，需要被回收掉。 如果你这个变量不是垃圾，那么它的所有成员变量的引用减一之后，refcount 必然不为0，需要将其从缓冲区移出去。 当垃圾回收机制打开时，每当根缓存区存满时，就会执行上面描述的循环查找算法。通过此方法解决循环引用的问题，可以将内存泄漏保持在一个阀值以下。\nPHP 7.x 在PHP7中，zval使用了新的实现方式，更改了内存分配和引用计数的存储方式。 不同的数据类型与PHP 5.x相比，引用计数的计算上也出现了一些差别。 简单数据类型（比如整形和浮点类型）也不需要计数； 这样可以节省大量的内存分配和内存管理等操做，从而性能获得很大的提高。 （以下案例是在PHP7.1.23下的结果，PHP7的各个版本不同会有会有一定的差异）\n整形和浮点类型 1 2 3 4 5 6 7 8 $var_int = 123; $var_float = 1.23; $var_int2 = $var_int; $var_float2 = $var_float; xdebug_debug_zval(\u0026#39;var_int\u0026#39;); xdebug_debug_zval(\u0026#39;var_float\u0026#39;); xdebug_debug_zval(\u0026#39;var_int2\u0026#39;); xdebug_debug_zval(\u0026#39;var_float2\u0026#39;); 1 2 3 4 5 6 7 8 var_int: (refcount=0, is_ref=0)int 123 var_float: (refcount=0, is_ref=0)float 1.23 var_int2: (refcount=0, is_ref=0)int 123 var_float2: (refcount=0, is_ref=0)float 1.23 在为int和float的类型的变量名申请zval_struct时，可以直接将变量的值存储到zval_struct.value中，对于这种简单的类型，就不会在对它们进行引用计数，而是拷贝的时候就直接赋值。这样就省掉了大量的引用计数相关的操作。\n当然对于那种根本没有值, 只有类型的类型, 也不需要引用计数了:\nIS_NULL IS_FALSE IS_TRUE 普通字符串类型 1 2 3 4 $var_string = \u0026#34;abc\u0026#34;.time(); xdebug_debug_zval(\u0026#39;var_string\u0026#39;); $var_string2 = $var_string; xdebug_debug_zval(\u0026#39;var_string\u0026#39;); 1 2 3 4 var_string: (refcount=1, is_ref=0)string \u0026#39;abc1629256042\u0026#39; (length=13) var_string: (refcount=2, is_ref=0)string \u0026#39;abc1629256042\u0026#39; (length=13) 普通字符串和PHP5的版本的计数是一样的。\n静态字符串类型 1 2 3 4 $var_string = \u0026#34;abc\u0026#34;; xdebug_debug_zval(\u0026#39;var_string\u0026#39;); $var_string2 = $var_string; xdebug_debug_zval(\u0026#39;var_string\u0026#39;); 1 2 3 4 var_string: (refcount=2, is_ref=0)string \u0026#39;abc\u0026#39; (length=3) var_string: (refcount=3, is_ref=0)string \u0026#39;abc\u0026#39; (length=3) 数组 1 2 3 4 5 $var_arr = [1,2.1,\u0026#39;abc\u0026#39;]; xdebug_debug_zval(\u0026#39;var_arr\u0026#39;); $var_arr2 = $var_arr; xdebug_debug_zval(\u0026#39;var_arr\u0026#39;); exit; 1 2 3 4 5 6 7 8 9 10 11 12 var_arr: (refcount=2, is_ref=0) array (size=3) 0 =\u0026gt; (refcount=0, is_ref=0)int 1 1 =\u0026gt; (refcount=0, is_ref=0)float 2.1 2 =\u0026gt; (refcount=1, is_ref=0)string \u0026#39;abc\u0026#39; (length=3) var_arr: (refcount=3, is_ref=0) array (size=3) 0 =\u0026gt; (refcount=0, is_ref=0)int 1 1 =\u0026gt; (refcount=0, is_ref=0)float 2.1 2 =\u0026gt; (refcount=1, is_ref=0)string \u0026#39;abc\u0026#39; (length=3) immutable array （不可变数组），在不可变数组和静态字符串下，初始使用一个伪计数值2。 我们可以尝试将数组元素改成可变的\n1 2 3 $var_arr = [1,2.1,time()]; xdebug_debug_zval(\u0026#39;var_arr\u0026#39;); exit; 1 2 3 4 5 6 var_arr: (refcount=1, is_ref=0) array (size=3) 0 =\u0026gt; (refcount=0, is_ref=0)int 1 1 =\u0026gt; (refcount=0, is_ref=0)float 2.1 2 =\u0026gt; (refcount=0, is_ref=0)int 1629254030 可变数组和PHP5的数字计数也是一样的。\n写时复制 对于多个引用来说，zaval 只有在没有变化的情况下才是共享的，一旦其中一个引用改变 zval 的值，就需要复制一份 zval，然后修改复制后的 zval。 写时复制的机制在计算机系统中有非常广的应用，它只有在必要的时候(写)才会发生硬拷贝，可以很好的提高效率。 通过一个简单的例子来说明:\n1 2 3 4 5 6 7 8 9 $a = 10; $b = $c = $a; xdebug_debug_zval(\u0026#39;a\u0026#39;); xdebug_debug_zval(\u0026#39;b\u0026#39;); xdebug_debug_zval(\u0026#39;c\u0026#39;); $a = 20; xdebug_debug_zval(\u0026#39;a\u0026#39;); xdebug_debug_zval(\u0026#39;b\u0026#39;); xdebug_debug_zval(\u0026#39;c\u0026#39;); 1 2 3 4 5 6 7 8 9 10 11 12 a: (refcount=3, is_ref=0),int 10 b: (refcount=3, is_ref=0),int 10 c: (refcount=3, is_ref=0),int 10 a: (refcount=1, is_ref=0),int 20 b: (refcount=2, is_ref=0),int 10 c: (refcount=2, is_ref=0),int 10 第一步变量a传值给变量b,c值都为10，a,b,c共享同一个zval变量容器，引用次数是3。 第二步当变量a重新赋值后，a复制了一分zval，refcount为1。剩下的b和c共享一个，引用次数refcount为2。\n可以看到，再值不变的情况，PHP是没有必要进行复制zval变量容器的。只有值变化时，共享的变量容器才会进行复制。\n参考 引用计数基本知识 回收周期 变量的内部实现 ","date":"2021-08-29T10:55:45+08:00","image":"https://weekthree.github.io/p/php-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/logo_hu95715a275f688f30e37c56d0c7fd7826_937083_120x120_fill_box_smart1_3.png","permalink":"https://weekthree.github.io/p/php-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","title":"PHP 垃圾回收机制"},{"content":"order by rand()存在的问题 想要从数据表中随机获取数据，MySQL给我们提供了rand()函数。但是，在使用的时候会发现，order by rand() 的查询效率非常低，我们可以验证一下。\n测试的表中总共有238万行数据\n1 2 3 4 5 6 7 mysql\u0026gt; select count(*) from 28hse_browse_all_back_up; +----------+ | count(*) | +----------+ | 2383872 | +----------+ 1 row in set (0.00 sec) 随机获取一行数据的花费\n1 2 3 4 5 6 7 mysql\u0026gt; SELECT id,mobile,district FROM 28hse_browse_all_back_up ORDER BY RAND() LIMIT 1; +--------+---------------+----------+ | id | mobile | district | +--------+---------------+----------+ | 915371 | +852-68964153 | 大埔 | +--------+---------------+----------+ 1 row in set (6.04 sec) 获取一条数据用了6.04秒，可谓非常之慢。\n为什么会这么慢 为什么花费这么久，我们看一下执行计划，分析一下\n1 2 3 4 5 6 7 mysql\u0026gt; desc SELECT id,mobile,district FROM 28hse_browse_all_back_up ORDER BY RAND() LIMIT 1; +----+-------------+--------------------------+------------+------+---------------+------+---------+------+---------+----------+---------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------------------------+------------+------+---------------+------+---------+------+---------+----------+---------------------------------+ | 1 | SIMPLE | 28hse_browse_all_back_up | NULL | ALL | NULL | NULL | NULL | NULL | 2273880 | 100.00 | Using temporary; Using filesort | +----+-------------+--------------------------+------------+------+---------------+------+---------+------+---------+----------+---------------------------------+ 1 row in set, 1 warning (0.00 sec) rows字段显示预计需要扫描220万行数据，差不多就是全表扫描了一次。 Extra字段显示Using temporary,表示的是需要使用临时表；Using filesort表示的是需要执行排序操作。因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。\n执行流程 这条语句的执行流程是这样的：\n创建临时表，优先会使用内存临时表，临时表的大小超过了tmp_table_size的配置就会转成磁盘临时表。 全表扫描，并用rand()为每一行生成对应的随机数，将数据放入到临时表中。 初始化sort_buffer,从内存表中读取所有行，取出随机数和rowid,放入sort_buffer中 在sort_buffer中根据随机数执行排序。 排序完成后，取出排在第一个的rowid,根据rowid到临时表中获取数据返回结果。 由于需要全表扫描，并且涉及到临时表和文件排序，所以在数据量比较大的表中，直接使用order by rand()获取随机数据是不明智的，查询会非常慢。\n优化思路 根据主键取随机 这个方案的思路就是，利用数据表中主键的最大值和最小值，生成一个随机数，然后查询表中主键大于等于这个数的第一行记录。\n步骤如下：\n取这个表主键id最大的值M和最小值N； 用随机函数生成M和N的随机数X; 取id不小于X的第一行 1 2 3 4 5 //测试表最小的id是1，最大的id是2633479 $min = 1; $max = 2633479; $number = mt_rand($min,$max); $sql = \u0026#34;select id,mobile,district from 28hse_browse_all_back_up where id \u0026gt;= {$number} limit 1\u0026#34;; 执行一下，随机数为1606750\n1 2 3 4 5 6 7 mysql\u0026gt; select id,mobile,district from 28hse_browse_all_back_up where id \u0026gt;= 1606750 limit 1; +---------+------------------------------+-----------------+ | id | mobile | district | +---------+------------------------------+-----------------+ | 1606750 | +852-94380883##+852-60152968 | 日出康城區 | +---------+------------------------------+-----------------+ 1 row in set (0.00 sec) 在MySQL中的执行时间已经是毫秒级的了，几乎可以忽略不计。\n查询非常快，但是会有一个问题，如果id中间有空洞的话，例如id分布是1,2,2000000,2000001\u0026hellip;，那么大概率会随机到id值比较大的那一行。\n根据行数取随机 这个方案的思路就是，根据数据总行数取随机，在数据表中获得随机行\n步骤如下：\n取得整个表的行数C 用随机函数生成1和C的随机数X; 使用limit X,1取得目标行 1 2 3 4 //测试表数据总行数为2633479 $count = 2633479; $number = mt_rand(0,$count); $sql = \u0026#34;select id,mobile,district from 28hse_browse_all_back_up limit {$number},1\u0026#34;; 执行一下，随机数为524982\n1 2 3 4 5 6 7 mysql\u0026gt; select id,mobile,district from 28hse_browse_all_back_up limit 524982,1; +--------+---------------+----------+ | id | mobile | district | +--------+---------------+----------+ | 685517 | +852-96510180 | 奧運 | +--------+---------------+----------+ 1 row in set (0.44 sec) 我们发现第二种方案的花费要比第一种方案的花费高了很多，这是因为MySQL处理limit X,1的做法就是按顺序一个一个的读出来，丢掉前Y个，然后将下一个的记录作为返回结果，因此需要扫描Y+1行，执行的代价比方案1高很多，而且随机出来行数越靠后，查询时间就越长。 但是相比方案1，主键存在空洞的情况也不会影响方案2的\u0026quot;随机性\u0026quot;。\n总结 不管是根据主键还是根据行数取随机，核心思想都是将生成随机的步骤抽离出来，减少MySQL的计算量。根据行数随机得到的数据\u0026quot;随机性\u0026quot;更高，但根据主键随机查询的数据会更快。具体选择什么方案，还是要根据表大小，查询速度和业务需要进行选择。\n参考 极客时间《MySQL实战45讲》- 林晓斌 ","date":"2021-05-29T10:55:45+08:00","image":"https://weekthree.github.io/p/mysql-%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%98%E5%8C%96/head_huc59a164d0141298d7c4ae946514d8aa5_506697_120x120_fill_box_smart1_3.png","permalink":"https://weekthree.github.io/p/mysql-%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%98%E5%8C%96/","title":"MySQL 获取随机数据的优化"},{"content":"介绍 Redis除了5大基本数据类型：String、List、Hash、Set和Sorted Set。还提供了3种拓展数据类型，分别是Bitmap、HyperLogLog和GEO。\nGEO是Redis 3.2 版本中新增的专门面向LBS应用的一种数据类型。使用它我们可以非常方便的实现一些**基于位置信息服务(Location-Based Service,LBS)**的应用。例如打车软件获得离用户最近的车辆信息。或者根据用户点阅的物件展示周边距离最近的物件。利用GEO和经纬度信息可以很简单的获取到数据。\n如何使用 数据存储Redis 使用前，需要将经纬度数据准备好，使用以下命令存储到Redis中。\n1 GEOADD key longitude latitude member [longitude latitude member ...] 例如，物件ID是1001的经纬度信息为114.143701,22.408597\n1 GEOADD data:locations 114.143701 22.408597 1001 将所有数据插入到Redis后，我们就可以开始获取想要的数据了。\n获取范围内的数据 根据经纬度 例如，我们想根据经纬度获得离它5km范围最近的三笔数据，按距离由近到远排序。\n1 2 3 4 \u0026gt; GEORADIUS data:locations 114.152801 22.411597 5 km ASC COUNT 3 1003 1001 1002 返回的数据就是按直线距离排序好的成员ID。其中参数5 km就是限制距离范围。支持多种单位长度\nm表中单位为米 km表示千米 mi表示英里 ft表示为英尺 根据已有成员 也可以直接根据已有成员的经纬度获得数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026gt; GEORADIUSBYMEMBER data:locations 1001 5 km ASC COUNT 3 WITHDIST WITHCOORD 1001 0.0000 114.14370328187942505 22.40859655827627961 1002 1.1170 114.14270013570785522 22.41859603324986239 1003 1.4382 114.15269941091537476 22.41849717912464968 这里我们是直接根据已有成员的经纬度获得的数据，输入的参数是成员的ID。 其中通过增加参数获得额外的信息\nWITHDIST\t返回与给定目标的直线距离 WITHCOORD\t返回经纬度信息 需要注意的是，ID为1001的自身也会一并返回。\n计算距离 根据两个成员计算距离\n1 2 \u0026gt; GEODIST data:locations 1001 1002 m 1116.9774 返回的结果为1116.9774，单位为米，同样的，可以通过参数指定单位。 和手写的计算距离的函数对比一下结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $lng1 = 114.14370328187942505; $lat1 = 22.40859655827627961; $lng2 = 114.14270013570785522; $lat2 = 22.41859603324986239; //将角度转为狐度 $radLat1 = deg2rad($lat1);//deg2rad()函数将角度转换为弧度 $radLat2 = deg2rad($lat2); $radLng1 = deg2rad($lng1); $radLng2 = deg2rad($lng2); $a = $radLat1 - $radLat2; $b = $radLng1 - $radLng2; $s = round((2 * asin(sqrt(pow(sin($a / 2), 2) + cos($radLat1) * cos($radLat2) * pow(sin($b / 2),2))) * 6378.137) * 1000); echo $s; 返回结果为1118米。\n实现原理 GEO 类型是把经纬度所在的区间编码作为 Sorted Set 中元素的权重分数，把和经纬度相关的 ID 作为 Sorted Set 中元素本身的值保存下来，本质上还是使用了有序集合存储数据。 这样相邻经纬度的查询就可以通过编码值的大小范围查询来实现了。\n为了能高效地对经纬度进行比较，Redis 采用了业界广泛使用的 GeoHash 编码方法。 GeoHash的编码实现的方法有点复杂，有兴趣的可以自行研究。 使用场景 利用GEO类型，可以很方便的获得计算距离的数据 还有这种按距离由近及远取周边物件的。 ","date":"2021-03-09T00:00:00Z","image":"https://weekthree.github.io/p/%E5%9F%BA%E4%BA%8Eredis-geo%E5%AE%9E%E7%8E%B0%E7%9A%84lbs%E5%8A%9F%E8%83%BD/113958-153525479855be_hucaf497879fd88850870101187042854f_810097_120x120_fill_q75_box_smart1.jpg","permalink":"https://weekthree.github.io/p/%E5%9F%BA%E4%BA%8Eredis-geo%E5%AE%9E%E7%8E%B0%E7%9A%84lbs%E5%8A%9F%E8%83%BD/","title":"基于Redis GEO实现的LBS功能"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://weekthree.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://weekthree.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://weekthree.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://weekthree.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode ","date":"2019-03-10T00:00:00Z","permalink":"https://weekthree.github.io/p/rich-content/","title":"Rich Content"},{"content":"فقرة 1 هذا النص هو مثال لنص يمكن أن يستبدل في نفس المساحة، لقد تم توليد هذا النص من مولد النص العربى، حيث يمكنك أن تولد مثل هذا النص أو العديد من النصوص الأخرى إضافة إلى زيادة عدد الحروف التى يولدها التطبيق. إذا كنت تحتاج إلى عدد أكبر من الفقرات يتيح لك مولد النص العربى زيادة عدد الفقرات كما تريد، النص لن يبدو مقسما ولا يحوي أخطاء لغوية، مولد النص العربى مفيد لمصممي المواقع على وجه الخصوص، حيث يحتاج العميل فى كثير من الأحيان أن يطلع على صورة حقيقية لتصميم الموقع. ومن هنا وجب على المصمم أن يضع نصوصا مؤقتة على التصميم ليظهر للعميل الشكل كاملاً،دور مولد النص العربى أن يوفر على المصمم عناء البحث عن نص بديل لا علاقة له بالموضوع الذى يتحدث عنه التصميم فيظهر بشكل لا يليق. هذا النص يمكن أن يتم تركيبه على أي تصميم دون مشكلة فلن يبدو وكأنه نص منسوخ، غير منظم، غير منسق، أو حتى غير مفهوم. لأنه مازال نصاً بديلاً ومؤقتاً.\nفقرة 2 هذا النص هو مثال لنص يمكن أن يستبدل في نفس المساحة، لقد تم توليد هذا النص من مولد النص العربى، حيث يمكنك أن تولد مثل هذا النص أو العديد من النصوص الأخرى إضافة إلى زيادة عدد الحروف التى يولدها التطبيق. إذا كنت تحتاج إلى عدد أكبر من الفقرات يتيح لك مولد النص العربى زيادة عدد الفقرات كما تريد، النص لن يبدو مقسما ولا يحوي أخطاء لغوية، مولد النص العربى مفيد لمصممي المواقع على وجه الخصوص، حيث يحتاج العميل فى كثير من الأحيان أن يطلع على صورة حقيقية لتصميم الموقع. ومن هنا وجب على المصمم أن يضع نصوصا مؤقتة على التصميم ليظهر للعميل الشكل كاملاً،دور مولد النص العربى أن يوفر على المصمم عناء البحث عن نص بديل لا علاقة له بالموضوع الذى يتحدث عنه التصميم فيظهر بشكل لا يليق. هذا النص يمكن أن يتم تركيبه على أي تصميم دون مشكلة فلن يبدو وكأنه نص منسوخ، غير منظم، غير منسق، أو حتى غير مفهوم. لأنه مازال نصاً بديلاً ومؤقتاً.\nتجربة RTL كلمة 1 Text كلمة 2\n","date":"2019-03-09T00:00:00Z","image":"https://weekthree.github.io/p/%D9%85%D8%AB%D8%A7%D9%84-%D9%86%D8%B5/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://weekthree.github.io/p/%D9%85%D8%AB%D8%A7%D9%84-%D9%86%D8%B5/","title":"مثال نص"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://weekthree.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://weekthree.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://weekthree.github.io/p/emoji-support/","title":"Emoji Support"}]